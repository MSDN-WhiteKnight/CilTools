<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CilTools.BytecodeAnalysis</name>
    </assembly>
    <members>
        <member name="T:CilTools.BytecodeAnalysis.Diagnostics">
            <summary>
            Provides tools to help investigate errors occuring in library methods.
            </summary>
        </member>
        <member name="E:CilTools.BytecodeAnalysis.Diagnostics.Error">
            <summary>
            Raised when error occurs in one of the methods in the library
            </summary>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CilAnalysis">
            <summary>
            Provides static methods that assist in parsing and analysing CIL bytecode
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetTypeName(System.Type)">
            <summary>
            Gets the name of .NET type in CIL notation
            </summary>
            <param name="t">Type for which name is requested</param>
            <exception cref="T:System.ArgumentNullException">t is null</exception>
            <remarks>Returns short type name, such as <c>int32</c>, if it exists. Otherwise returns full name.</remarks>
            <returns>Short of full type name</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetTypeFullName(System.Type)">
            <summary>
            Gets the full name of .NET type in CIL notation
            </summary>
            <param name="t">Type for which name is requested</param>
            <exception cref="T:System.ArgumentNullException">t is null</exception>
            <remarks>Returns fully qualified name, such as <c>class [mscorlib]System.String</c></remarks>
            <returns>Full type name</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.EscapeString(System.String)">
            <summary>
            Escapes special characters in the specified string, using rules similar to what are applied to C# string literals
            </summary>
            <param name="str">The string to escape</param>
            <returns>The escaped string</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.MethodToText(System.Reflection.MethodBase)">
            <summary>
            Returns specified method CIL code as string
            </summary>
            <param name="m">Method for which to retrieve CIL</param>
            <remarks>The CIL code returned by this API is intended mainly for reading, not compiling. It is not guaranteed to be a valid input for CIL assembler.</remarks>
            <returns>CIL code string</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetReferencedMethods(System.Reflection.MethodBase)">
            <summary>
            Gets all methods that are referenced by the specified method
            </summary>
            <param name="mb">Method for which to retrieve referenced methods</param>
            <exception cref="T:System.ArgumentNullException">Source method is null</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in source method's body. For example, if the source method calls `Foo` method or creates delegate pointing to `Foo`, `Foo` is referenced by the source method.</remarks>
            <returns>A collection of referenced methods</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetReferencedMembers(System.Reflection.MethodBase)">
            <summary>
            Gets all members (fields or methods) referenced by specified method
            </summary>
            <param name="mb">Method for which to retrieve referenced members</param>
            <exception cref="T:System.ArgumentNullException">Source method is null</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in source method's body. For example, if the source method calls `Foo` method or creates delegate pointing to `Foo`, `Foo` is referenced by the source method.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetReferencedMembers(System.Reflection.MethodBase,CilTools.BytecodeAnalysis.MemberCriteria)">
            <summary>
            Gets members (fields or methods) referenced by specified method that match specified criteria
            </summary>
            <param name="mb">Method for which to retrieve referenced members</param>
            <param name="flags">A combination of bitwise flags that control what kind of members are retrieved</param>
            <exception cref="T:System.ArgumentNullException">Source method is null</exception>
            <exception cref="T:System.NotSupportedException">CilReader encountered unknown opcode</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Failed to retrieve method body for the method</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in source method's body. For example, if the source method calls `Foo` method or creates delegate pointing to `Foo`, `Foo` is referenced by the source method.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetReferencedMethods(System.Type)">
            <summary>
            Get all methods that are referenced by the code of the specified type
            </summary>
            <param name="t">Type for which to retrieve referenced methods</param>
            <exception cref="T:System.ArgumentNullException">Source type is null</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the type's methods.</remarks>
            <returns>A collection of referenced methods</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetReferencedMembers(System.Type)">
            <summary>
            Gets all members referenced by the code of specified type
            </summary>
            <param name="t">Type for which to retrieve referenced members</param>
            <exception cref="T:System.ArgumentNullException">Source type is null</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the type's methods.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetReferencedMembers(System.Type,CilTools.BytecodeAnalysis.MemberCriteria)">
            <summary>
            Gets members referenced by the code of specified type that match specified criteria
            </summary>
            <param name="t">Type for which to retrieve referenced members</param>
            <param name="flags">A combination of bitwise flags that control what kind of members are retrieved</param>
            <exception cref="T:System.ArgumentNullException">Source type is null</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the type's methods.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetReferencedMethods(System.Reflection.Assembly)">
            <summary>
            Get all methods that are referenced by the code in the specified assembly
            </summary>
            <param name="ass">Assembly for which to retrieve referenced methods</param>
            <exception cref="T:System.ArgumentNullException">Source assembly is null</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the assembly's methods.</remarks>
            <returns>A collection of referenced methods</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetReferencedMembers(System.Reflection.Assembly)">
            <summary>
            Gets all members referenced by the code of specified assembly
            </summary>
            <param name="ass">Assembly for which to retrieve referenced members</param>
            <exception cref="T:System.ArgumentNullException">Source assembly is null</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the assembly's methods.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilAnalysis.GetReferencedMembers(System.Reflection.Assembly,CilTools.BytecodeAnalysis.MemberCriteria)">
            <summary>
            Gets members referenced by the code of specified assembly that match specified criteria
            </summary>
            <param name="ass">Assembly for which to retrieve referenced members</param>
            <param name="flags">A combination of bitwise flags that control what kind of members are retrieved</param>
            <exception cref="T:System.ArgumentNullException">Source assembly is null</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the assembly's methods.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.MemberCriteria">
            <summary>
            Represents bitwise flags that define what kinds of members are requested 
            </summary>
            <remarks>External members are members defined in different assembly then the method which references them, not to be confused with `external` keyword in C#. Internal members are members defined in the same assembly as referencing method, similarly, not to be confused with `internal` keyword or `InternalCall` attribute.  If you specify a combination of flags that does not match anything (i.e., if you define neither external nor internal members, or neither methods nor fields) when requesting referenced members, empty collection is returned.</remarks>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.MemberCriteria.External">
            <summary>
            Return external (not from the same assembly as containing method) members
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.MemberCriteria.Internal">
            <summary>
            Return internal (from the same assembly as containing method) members 
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.MemberCriteria.Methods">
            <summary>
            Return methods (including constructors)
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.MemberCriteria.Fields">
            <summary>
            Return fields
            </summary>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CilErrorEventArgs">
            <summary>
            Represents data associated with Error event
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilErrorEventArgs._Exception">
            <summary>
            Exception associated with this event
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilErrorEventArgs._Info">
            <summary>
            Additional information associated with this event
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilErrorEventArgs._Timestamp">
            <summary>
            A date and time when this event occured
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilErrorEventArgs.Exception">
            <summary>
            Gets exception associated with this event
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilErrorEventArgs.Info">
            <summary>
            Gets additional information associated with this event
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilErrorEventArgs.Timestamp">
            <summary>
            Gets date and time when this event occured
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilErrorEventArgs.#ctor(System.Exception,System.String)">
            <summary>
            Creates new CilErrorEventArgs object with specified Exception and error information
            </summary>
            <param name="ex">Exception associated with this event</param>
            <param name="info">Additional information associated with this event</param>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CilInstruction">
            <summary>
            Represents CIL instruction, a main structural element of the method body which consists of operation code and operand.
            </summary>
            <remarks>To retrieve a collection of CIL instructions for the specified method, use methods of <see cref="T:CilTools.BytecodeAnalysis.CilReader"/> class.</remarks>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilInstruction._Method">
            <summary>
            A reference to a method which this instruction belongs to
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilInstruction._OpCode">
            <summary>
            Opcode of this instruction
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilInstruction._ByteOffset">
            <summary>
            Byte offset of this instruction from the beginning of the method body
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilInstruction._OrdinalNumber">
            <summary>
            Ordinal number of the place this instruction takes in method body, starting from one.
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.Method">
            <summary>
            Gets a reference to a method which this instruction belongs to
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.OpCode">
            <summary>
            Gets the operation code (opcode) of this instruction
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.Operand">
            <summary>
            Gets the operand object of this instruction
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.OperandSize">
            <summary>
            Gets the size, in bytes, of this instruction's operand
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.ByteOffset">
            <summary>
            Gets a byte offset of this instruction from the beginning of the method body
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.OrdinalNumber">
            <summary>
            Gets ordinal number of the place this instruction takes in method body, starting from one.
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.Code">
            <summary>
            Gets opcode of this instruction as a numerical value
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.Name">
            <summary>
            Gets a name of this instruction
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.TotalSize">
            <summary>
            Gets total size, in bytes, that this instruction occupies in the method body
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilInstruction.#ctor(System.Reflection.Emit.OpCode,System.UInt32,System.UInt32,System.Reflection.MethodBase)">
            <summary>
            Creates a new CilInstruction object initialized with specified field values (infrastructure)
            </summary>
            <param name="opc">Opcode</param>
            <param name="byteoffset">Byte offset</param>
            <param name="ordinalnum">Ordinal number</param>
            <param name="mb">Owning method</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilInstruction.CreateEmptyInstruction(System.Reflection.MethodBase)">
            <summary>
            Creates new CilInstruction object that represents an empty instruction
            </summary>
            <param name="mb">Owning method</param>
            <returns>Empty CilInstruction object</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilInstruction.Create``1(System.Reflection.Emit.OpCode,``0,System.UInt32,System.UInt32,System.UInt32,System.Reflection.MethodBase)">
            <summary>
            Creates new CilInstruction object for instruction with operand
            </summary>
            <typeparam name="T">Operand type</typeparam>
            <param name="opc">Instruction opcode</param>
            <param name="operand">Operand value</param>
            <param name="operandsize">Operand size in bytes</param>
            <param name="byteoffset">Byte offset</param>
            <param name="ordinalnum">Ordinal number</param>
            <param name="mb">Owning method</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilInstruction.Create(System.Reflection.Emit.OpCode,System.UInt32,System.UInt32,System.Reflection.MethodBase)">
            <summary>
            Creates new CilInstruction object for instruction without operand
            </summary>
            <param name="opc">Instruction opcode</param>
            <param name="byteoffset">Byte offset</param>
            <param name="ordinalnum">Ordinal number</param>
            <param name="mb">Owning method</param>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.OperandType">
            <summary>
            Gets this instruction's operand type, or null if there's no operand
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.ReferencedMember">
            <summary>
            Gets a member (type, field or method) referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.ReferencedType">
            <summary>
            Gets a type referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.ReferencedString">
            <summary>
            Gets a string literal referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.ReferencedSignature">
            <summary>
            Gets a signature referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.ReferencedParameter">
            <summary>
            Gets the information about method parameter referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstruction.ReferencedLocal">
            <summary>
            Gets the information about local variable referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilInstruction.OperandToString(System.IO.TextWriter)">
            <summary>
            Writes the text representation of this instruction's operand into the specified TextWriter
            </summary>
            <param name="target">The destination TextWriter</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilInstruction.ToString">
            <summary>
            Returns a text representation of this instruction as a line of CIL code
            </summary>
            <returns>String containing text representation of this instruction</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilInstruction.EmitTo(System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits CIL code for this instruction into the specified IL generator.
            </summary>
            <param name="ilg">Target IL generator.</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilInstruction.Parse(System.String)">
            <summary>
            Converts CIL instruction textual representation into the corresponding CilInstruction object
            </summary>
            <param name="str">The line of CIL code representing instruction</param>
            <returns>CilInstruction object for the specified string</returns>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilTokenInstruction.ReferencedString">
            <summary>
            Gets a string literal referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilTokenInstruction.ReferencedSignature">
            <summary>
            Gets a signature referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CustomModifier">
            <summary>
            Represents custom modifier, an object used to associate a special information with the type specification, as defined by ECMA-335
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CustomModifier.IsRequired">
            <summary>
            Gets the value indicating whether this modifier is required or optional
            </summary>
            <value>
            'true' if type users are required to understand this modifier in order to correctly use it, 'false' if the modifier can be ignored
            </value>
            <remarks>
            See ECMA-335 I.9.7 (Metadata extensibility) for more information about required and optional modifiers
            </remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CustomModifier.ModifierType">
            <summary>
            Gets the type of this modifier
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CustomModifier.ToString">
            <summary>
            Gets the textual representation of this modifier as CIL code
            </summary>
            <returns></returns>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.DebugUtils">
            <summary>
            A collection of utility methods to assist in debugging
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.DebugUtils.GetExecutingInstruction(System.Diagnostics.StackFrame)">
            <summary>
            Gets an currently executing instruction corresponding to the specified stack frame
            </summary>
            <param name="sf">A stack frame object</param>
            <exception cref="T:System.ArgumentNullException">Source stack frame is null</exception>
            <returns>CIL instruction</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.DebugUtils.GetLastExecutedInstruction(System.Diagnostics.StackFrame)">
            <summary>
            Gets a last executed instruction corresponding to the specified stack frame
            </summary>
            <param name="sf">A stack frame object</param>
            <exception cref="T:System.ArgumentNullException">Source stack frame is null</exception>
            <returns>CIL instruction</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.DebugUtils.GetLastExecutedInstruction">
            <summary>
            Gets a last executed instruction at the calling point of the code
            </summary>
            <returns>CIL instruction</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.DebugUtils.GetStackTrace">
            <summary>
            Gets a stack trace at the calling point represented as CIL instructions
            </summary>
            <returns>A collection of CIL instructions corresponding to frames of a callstack</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.DebugUtils.PrintStackTrace">
            <summary>
            Prints a stack trace at the calling point, represented as a CIL code, into the standard output
            </summary>        
        </member>
        <member name="M:CilTools.BytecodeAnalysis.DebugUtils.GetStackTrace(System.Diagnostics.StackTrace)">
            <summary>
            Gets a repesentation of the call stack as CIL instructions
            </summary>
            <param name="trace">Stack trace object</param>
            <exception cref="T:System.ArgumentNullException">Source stack trace is null</exception>
            <returns>A collection of CIL instructions</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.DebugUtils.PrintStackTrace(System.Diagnostics.StackTrace,System.IO.TextWriter)">
            <summary>
            Prints a stack trace, represented as a CIL code, into the specified TextWriter
            </summary>
            <param name="trace">Source stack trace object</param>
            <param name="target">Target TextWriter object. If null or omitted, standard output will be used.</param>
            <exception cref="T:System.ArgumentNullException">Source stack trace is null</exception>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CilGraph">
            <summary>
            Represents a CIL graph, a graph that reflects a flow of control between CIL instructions in the method
            </summary>
            <remarks>
            <para>CIL graph is a directed graph with nodes representing CIL instructions withing method body and edges representing how control flows between them when runtime executes method. The root of the graph is the first instruction of the method. Each node stores a reference to the next instruction (which is usually executed after it) and, if it's a jump instruction, a reference to the branch target (an instruction that would be executed if the condition for the jump is met). For convenience, each instruction serving as branch target is assigned a label, a string that identify it. The last instruction of the method has null as its next instruction reference.</para>
            <para>Use <see cref="M:CilTools.BytecodeAnalysis.CilGraph.Create(System.Reflection.MethodBase)"/> method to create CIL graph for a method.</para>
            </remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.Create(System.Reflection.MethodBase)">
            <summary>
            Returns <see cref="T:CilTools.BytecodeAnalysis.CilGraph"/> that represents a specified method
            </summary>
            <param name="m">Method for which to build CIL graph</param>
            <exception cref="T:System.ArgumentNullException">Source method is null</exception>
            <returns>CIL graph object</returns>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilGraph._Root">
            <summary>
            A root node of this graph (the first instruction in the method)
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilGraph._Method">
            <summary>
            A method object for which this graph is built
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.#ctor(CilTools.BytecodeAnalysis.CilGraphNode,System.Reflection.MethodBase)">
            <summary>
            Creates new CIL graph. (Insfrastructure; not intended for user code)
            </summary>
            <param name="root">Root node</param>
            <param name="mb">Method associated with this graph object</param>
            <remarks>Use <see cref="M:CilTools.BytecodeAnalysis.CilGraph.Create(System.Reflection.MethodBase)"/> method to create CIL graph for a method instead of using this 
            contructor.</remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraph.Root">
            <summary>
            Gets a root node of this graph (the first instruction in the method)
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraph.Method">
            <summary>
            Gets a method for which this graph is built
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.PrintSignature(System.IO.TextWriter)">
            <summary>
            Writes the signature of the method represented by this graph into the specified TextWriter
            </summary>
            <param name="output">The destination TextWriter</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.PrintDefaults(System.IO.TextWriter)">
            <summary>
            Writes default parameter values of the method represented by this graph into the specified TextWriter
            </summary>
            <param name="output">The destination TextWriter</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.PrintAttributes(System.IO.TextWriter)">
            <summary>
            Writes custom attributes of the method represented by this graph into the specified TextWriter
            </summary>
            <param name="output">The destination TextWriter</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.PrintHeader(System.IO.TextWriter)">
            <summary>
            Writes the method header code of the method represented by this graph into the specified TextWriter
            </summary>
            <param name="output">The destination TextWriter</param>
            <remarks>
            The method header in CLI contains information such as stack size and local variables.
            </remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.Print(System.IO.TextWriter,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Writes the CIL code corresponding to this graph into the specified TextWriter, optionally including signature, 
            default parameter values, attributes and method header
            </summary>
            <param name="output">The destination TextWriter, or null to use standard output</param>
            <param name="IncludeSignature">Indicates that method signature should be included in the output</param>
            <param name="IncludeDefaults">Indicates that default parameter values should be included in the output</param>
            <param name="IncludeAttributes">Indicates that custom attributes should be included in the output</param>
            <param name="IncludeHeader">Indicates that method header should be included in the output</param>
            <remarks>
            <para>The CIL code produced by this API is intended mainly for reading, not compiling. It is not guaranteed to be a valid  input for CIL assembler.</para>
            <para>Method header contains information such as maximum stack size and local variable types.</para>
            </remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.ToSyntaxTree">
            <summary>
            Gets the syntax tree for the method represented by this graph
            </summary>
            <returns>The root method definition node of the syntax tree</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.ToText">
            <summary>
            Returns CIL code corresponding to this graph as a string
            </summary>
            <remarks>The CIL code returned by this API is intended mainly for reading, not compiling. It is not guaranteed to be a valid input for CIL assembler.</remarks>
            <returns>A string of CIL code</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.ToString">
            <summary>
            Returns the signature of the method represented by this graph
            </summary>
            <returns>The string with method signature</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.GetNodes">
            <summary>
            Enumerates nodes in this graph
            </summary>
            <returns>The collection of graph nodes</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.GetInstructions">
            <summary>
            Enumerates all instructions represented by this graph's nodes
            </summary>
            <returns>The collection of instructions</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraph.EmitTo(System.Reflection.Emit.ILGenerator,System.Func{CilTools.BytecodeAnalysis.CilInstruction,System.Boolean})">
            <summary>
            Emits the entire content of this CIL graph into the specified IL generator, 
            optionally calling user callback for each processed instruction.
            </summary>
            <param name="gen">Target IL generator. </param>
            <param name="callback">User callback to be called for each processed instruction.</param>
            <remarks>Passing user callback into this method enables you to filter instructions that you want to be emitted 
            into target IL generator. 
            Return <see langword="true"/> to skip emitting instruction, or <see langword="false"/> to emit instruction.</remarks>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CilGraphNode">
            <summary>
            Represents a node in the CIL graph. A node describes an instruction and its connection with other instructions
            </summary>
            <remarks>See <see cref="T:CilTools.BytecodeAnalysis.CilGraph"/> class documentation for more information about CIL graphs.</remarks>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilGraphNode._Instruction">
            <summary>
            CIL instruction associated with this node
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilGraphNode._Name">
            <summary>
            Optional label name associated with this node
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilGraphNode._Previous">
            <summary>
            A reference to the node that represents instruction directly preceding current instruction in the method bytecode
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilGraphNode._Next">
            <summary>
            A reference to the node that represents instruction directly following current instruction in the method bytecode
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilGraphNode._BranchTarget">
            <summary>
            A reference to the node that represents instruction which is a target of the current instruction, if applicable
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilGraphNode._SwitchTargets">
            <summary>
            An array of nodes that represents the jump table of the switch instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNode.Instruction">
            <summary>
            Gets CIL instruction associated with this node
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNode.Name">
            <summary>
            Gets label name associated with this node
            </summary>
            <remarks>Label names are assigned to instruction that serve as branch targets for convenience. If the instruction is not used as target, the value is empty string.</remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNode.Previous">
            <summary>
            Gets a reference to the node that represents instruction directly preceding current instruction in the method bytecode
            </summary>
            <remarks>For the first instruction in the method body, the value is null.</remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNode.Next">
            <summary>
            Gets a reference to the node that represents instruction directly following current instruction in the method bytecode
            </summary>
            <remarks>Next instruction will be normally executed after current one, unless it is a jump instruction and the condition for jump is met. For the last instruction of the method body, the value is null.</remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNode.BranchTarget">
            <summary>
            Gets a reference to the node that represents instruction which is a target of the current instruction, if applicable
            </summary>
            <remarks>Branch target is an instruction which would be called after current one if the condition for jump instruction is met. For non-jump instructions, the value is null.</remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraphNode.GetSwitchTargets">
            <summary>
            Gets an array of nodes that represents the jump table of the switch instruction, if applicable
            </summary>
            <remarks>Jump table is the sequence of instructions corresponding to the switch instruction. When runtime processes switch instruction, it will transfer control to one of the instructions based on the value pushed to the stack. For non-switch instructions, returns an empty array.</remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraphNode.#ctor">
            <summary>
            Creates new CilGraphNode object
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraphNode.ToString">
            <summary>
            Returns text representation of this node as a line of CIL code
            </summary>
            <returns>String that contatins a text representation of this node</returns>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CilGraphNodeMutable">
            <summary>
            A mutable version of CilGraphNode class
            </summary>    
            <remarks>Graph nodes are exposed as immutable <see cref="T:CilTools.BytecodeAnalysis.CilGraphNode"/> objects by API of this library, such as <see cref="M:CilTools.BytecodeAnalysis.CilGraph.Create(System.Reflection.MethodBase)"/> method, because usually you don't need to alter their properties. However, these nodes are created as mutable objects and their actual runtime type is CilGraphNodeMutable; you can cast them to that type if you need to set their properties.</remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraphNodeMutable.#ctor(CilTools.BytecodeAnalysis.CilInstruction)">
            <summary>
            Creates new mutable CIL graph node object
            </summary>
            <param name="instr">An instruction associated with this node</param>
            <exception cref="T:System.ArgumentNullException">instr argument is null</exception>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNodeMutable.Instruction">
            <summary>
            Gets or sets CIL instruction associated with this node
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNodeMutable.Name">
            <summary>
            Gets or sets label name associated with this node
            </summary>
            <remarks>Label names are assigned to instruction that serve as branch targets for convenience. If the instruction is not used as target, the value is empty string.</remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNodeMutable.Previous">
            <summary>
            Gets or sets a reference to the node that represents instruction directly preceding current instruction in the method bytecode
            </summary>
            <remarks>For the first instruction in the method body, the value is null.</remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNodeMutable.Next">
            <summary>
            Gets or sets a reference to the node that represents instruction directly following current instruction in the method bytecode
            </summary>
            <remarks>Next instruction will be normally executed after current one, unless it is a jump instruction and the condition for jump is met. For the last instruction of the method body, the value is null.</remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilGraphNodeMutable.BranchTarget">
            <summary>
            Gets or sets a reference to the node that represents instruction which is a target of the current instruction, if applicable
            </summary>
            <remarks>Branch target is an instruction which would be called after current one if the condition for jump instruction is met. For non-jump instructions, the value is null.</remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilGraphNodeMutable.SetSwitchTargets(CilTools.BytecodeAnalysis.CilGraphNode[])">
            <summary>
            Sets the array of nodes that represents the jump table of the switch instruction
            </summary>
            <remarks>Jump table is the sequence of instructions corresponding to the switch instruction. When runtime processes switch instruction, it will transfer control to one of the instructions based on the value pushed to the stack. </remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstructionImpl`1.ReferencedMember">
            <summary>
            Gets a member (type, field or method) referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstructionImpl`1.ReferencedString">
            <summary>
            Gets a string literal referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstructionImpl`1.ReferencedSignature">
            <summary>
            Gets a signature referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstructionImpl`1.ReferencedParameter">
            <summary>
            Gets the information about method parameter referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilInstructionImpl`1.ReferencedLocal">
            <summary>
            Gets the information about local variable referenced by this instruction, if applicable
            </summary>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CilReaderState">
            <summary>
            Represents a state of CilReader object
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilReaderState.Reading">
            <summary>
            CilReader can read instructions
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilReaderState.Error">
            <summary>
            CilReader is in a faulty state, because previous read operation resulted in error
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilReaderState.End">
            <summary>
            CilReader reached the end of its source data
            </summary>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CilParserException">
            <summary>
            Represents an error during CIL reading operation
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilParserException.#ctor(System.String)">
            <summary>
            Creates new CilParserException object
            </summary>
            <param name="message">Error message for this exception</param>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CilReader">
            <summary>
            Sequentially processes CIL bytecode, reading instructions from the method body
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilReader.cilbytes">
            <summary>
            Raw CIL bytes which this object processes
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilReader.current_pos">
            <summary>
            Current position in the source array
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilReader.current_ordinal">
            <summary>
            An ordinal number of the next instruction
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilReader.state">
            <summary>
            Current state of this object
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CilReader.method">
            <summary>
            A method which body this object reads
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilReader.Method">
            <summary>
            Gets a method which body this CilReader object reads
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.CilReader.State">
            <summary>
            Gets a current state of this CilReader object
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilReader.#ctor(System.Byte[])">
            <summary>
            Creates new CilReader object that uses specified byte array as source
            </summary>
            <exception cref="T:System.ArgumentNullException">Source array is null</exception>
            <exception cref="T:System.ArgumentException">Source array is empty</exception>
            <param name="src">An array of bytecode to read from</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilReader.#ctor(System.Reflection.MethodBase)">
            <summary>
            Creates new CilReader that uses a body of specified method as a source
            </summary>
            <exception cref="T:System.ArgumentNullException">Source method is null</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">GetMethodBody returned null</exception>
            <param name="src">A MethodBase object that specifies a method to read from</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilReader.Read">
            <summary>
            Reads next instruction from source
            </summary>
            <exception cref="T:System.InvalidOperationException">This CilReader is in faulty state or reached the end of source byte array</exception>
            <exception cref="T:System.NotSupportedException">CilReader encountered unknown opcode</exception>
            <returns>CilInstruction retrieved from the source</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilReader.ReadAll">
            <summary>
            Reads all instructions from source until the end is reached
            </summary>        
            <exception cref="T:System.NotSupportedException">CilReader encountered unknown opcode</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Unknown error occured</exception>
            <returns>A collection of CIL instructions</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilReader.GetInstructions(System.Byte[])">
            <summary>
            Reads all instructions from specified array of bytecode
            </summary>
            <param name="src">Source byte array</param>
            <exception cref="T:System.ArgumentNullException">Source array is null</exception>
            <exception cref="T:System.ArgumentException">Source array is empty</exception>
            <exception cref="T:System.NotSupportedException">CilReader encountered unknown opcode</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Unknown error occured</exception>
            <returns>A collection of CIL instructions</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.CilReader.GetInstructions(System.Reflection.MethodBase)">
            <summary>
            Reads all instructions from specified method's body
            </summary>
            <param name="m">Source method</param>
            <exception cref="T:System.ArgumentNullException">Source method is null</exception>        
            <exception cref="T:System.NotSupportedException">CilReader encountered unknown opcode</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Failed to retrieve method body for the method</exception>
            <returns>A collection of CIL instructions that form the body of this method</returns>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.Extensions.CilExtensions">
            <summary>
            A collection of extension methods that provide an alternative syntax for some static methods of this library
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetCilGraph(System.Reflection.MethodBase)">
            <summary>
            Returns <see cref="T:CilTools.BytecodeAnalysis.CilGraph"/> that represents this method
            </summary>
            <param name="m">Method for which to build CIL graph</param>
            <returns>CIL graph object</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetCilText(System.Reflection.MethodBase)">
            <summary>
            Returns this method's CIL code as string
            </summary>
            <param name="m">Method for which to retrieve CIL</param>
            <remarks>Alias for <see cref="M:CilTools.BytecodeAnalysis.CilAnalysis.MethodToText(System.Reflection.MethodBase)"/> method. The CIL code returned by this API is intended mainly for reading, not compiling. It is not guaranteed to be a valid input for CIL assembler.</remarks>
            <returns>CIL code string</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetInstructions(System.Reflection.MethodBase)">
            <summary>
            Retrieves all instructions from the method's body
            </summary>
            <param name="m">Source method</param>
            <exception cref="T:System.NotSupportedException">CilReader encountered unknown opcode</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Failed to retrieve method body for the method</exception>
            <returns>A collection of CIL instructions that form the body of this method</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetExecutingInstruction(System.Diagnostics.StackFrame)">
            <summary>
            Gets an currently executing instruction corresponding to this stack frame
            </summary>
            <param name="sf">A stack frame object</param>
            <returns>CIL instruction</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetLastExecutedInstruction(System.Diagnostics.StackFrame)">
            <summary>
            Gets a last executed instruction corresponding to this stack frame
            </summary>
            <param name="sf">A stack frame object</param>
            <returns>CIL instruction</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetInstructions(System.Diagnostics.StackTrace)">
            <summary>
            Gets a repesentation of this stack trace as CIL instructions
            </summary>
            <param name="trace">Stack trace object</param>
            <returns>A collection of CIL instructions</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.PrintInstructions(System.Diagnostics.StackTrace,System.IO.TextWriter)">
            <summary>
            Prints this stack trace, represented as a CIL code, into the specified TextWriter
            </summary>
            <param name="trace">Source stack trace object</param>
            <param name="target">Target TextWriter object. If null or omitted, standard output will be used.</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetReferencedMethods(System.Reflection.MethodBase)">
            <summary>
            Gets all methods that are referenced by this method
            </summary>
            <param name="mb">Method for which to retrieve referenced methods</param>
            <exception cref="T:System.NotSupportedException">CilReader encountered unknown opcode</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Failed to retrieve method body for the method</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in source method's body. For example, if the source method calls `Foo` method or creates delegate pointing to `Foo`, `Foo` is referenced by the source method.</remarks>
            <returns>A collection of referenced methods</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetReferencedMethods(System.Type)">
            <summary>
            Get all methods that are referenced by the code of this type
            </summary>
            <param name="t">Type for which to retrieve referenced methods</param>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the type's methods.</remarks>
            <returns>A collection of referenced methods</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetReferencedMethods(System.Reflection.Assembly)">
            <summary>
            Get all methods that are referenced by the code in the specified assembly
            </summary>
            <param name="ass">Assembly for which to retrieve referenced methods</param>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the assembly's methods.</remarks>
            <returns>A collection of referenced methods</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetReferencedMembers(System.Reflection.MethodBase)">
            <summary>
            Gets all members (fields or methods) referenced by specified method
            </summary>
            <param name="mb">Method for which to retrieve referenced members</param>
            <exception cref="T:System.NotSupportedException">CilReader encountered unknown opcode</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Failed to retrieve method body for the method</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in source method's body. For example, if the source method calls `Foo` method or creates delegate pointing to `Foo`, `Foo` is referenced by the source method.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetReferencedMembers(System.Type)">
            <summary>
            Gets all members referenced by the code of specified type
            </summary>
            <param name="t">Type for which to retrieve referenced memmbers</param>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the type's methods.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetReferencedMembers(System.Reflection.Assembly)">
            <summary>
            Gets all members referenced by the code of specified assembly
            </summary>
            <param name="ass">Assembly for which to retrieve referenced members</param>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the assembly's methods.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetReferencedMembers(System.Reflection.MethodBase,CilTools.BytecodeAnalysis.MemberCriteria)">
            <summary>
            Gets members (fields or methods) referenced by specified method that match specified criteria
            </summary>
            <param name="mb">Method for which to retrieve referenced members</param>
            <param name="flags">A combination of bitwise flags that control what kind of members are retrieved</param>
            <exception cref="T:System.NotSupportedException">CilReader encountered unknown opcode</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Failed to retrieve method body for the method</exception>
            <remarks>Referenced member is a member that appears as an operand of instruction in source method's body. For example, if the source method calls `Foo` method or creates delegate pointing to `Foo`, `Foo` is referenced by the source method.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetReferencedMembers(System.Type,CilTools.BytecodeAnalysis.MemberCriteria)">
            <summary>
            Gets members referenced by the code of specified type that match specified criteria
            </summary>
            <param name="t">Type for which to retrieve referenced memmbers</param>
            <param name="flags">A combination of bitwise flags that control what kind of members are retrieved</param>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the type's methods.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.GetReferencedMembers(System.Reflection.Assembly,CilTools.BytecodeAnalysis.MemberCriteria)">
            <summary>
            Gets members referenced by the code of specified assembly that match specified criteria
            </summary>
            <param name="ass">Assembly for which to retrieve referenced members</param>
            <param name="flags">A combination of bitwise flags that control what kind of members are retrieved</param>
            <remarks>Referenced member is a member that appears as an operand of instruction in any of the assembly's methods.</remarks>
            <returns>A collection of MemberInfo objects</returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.EmitInstruction(System.Reflection.Emit.ILGenerator,CilTools.BytecodeAnalysis.CilInstruction)">
            <summary>
            Emits CIL code for the specified instruction into the specified IL generator.
            </summary>
            <param name="ilg">Target IL generator.</param>
            <param name="instr">IL instruction to be emitted.</param>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Extensions.CilExtensions.EmitCilGraph(System.Reflection.Emit.ILGenerator,CilTools.BytecodeAnalysis.CilGraph,System.Func{CilTools.BytecodeAnalysis.CilInstruction,System.Boolean})">
            <summary>
            Emits the entire content of CIL graph into the specified IL generator, 
            optionally calling user callback for each processed instruction.
            </summary>
            <param name="ilg">Target IL generator. </param>
            <param name="graph">The CIL graph which content should be emitted.</param>
            <param name="callback">User callback to be called for each processed instruction.</param>
            <remarks>Passing user callback into this method enables you to filter instructions that you want to be emitted 
            into target IL generator. 
            Return <see langword="true"/> to skip emitting instruction, or <see langword="false"/> to emit instruction.</remarks>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.CallingConvention">
            <summary>
            Represents calling convention, a set of rules defining how the function interacts with its caller, as defined by ECMA-335
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CallingConvention.Default">
            <summary>
            Default managed calling convention (fixed amount of arguments)
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CallingConvention.CDecl">
            <summary>
            C language calling convention
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CallingConvention.StdCall">
            <summary>
            Standard x86 calling convention
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CallingConvention.ThisCall">
            <summary>
            Calling convention for C++ class member functions
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CallingConvention.FastCall">
            <summary>
            Optimized x86 calling convention
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.CallingConvention.Vararg">
            <summary>
            Managed calling convention with variable amount of arguments
            </summary>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.Signature">
            <summary>
            Encapsulates function's return type, calling convention and parameter types
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Signature.#ctor(System.Byte[],System.Reflection.Module)">
            <summary>
            Initializes a new Signature object representing a stand-alone method signature
            </summary>
            <param name="data">The byte array containing StandAloneMethodSig data (ECMA-335 II.23.2.3)</param>
            <param name="module">Module containing the passed signature</param>
            <exception cref="T:System.ArgumentNullException">Source array is null</exception>
            <exception cref="T:System.ArgumentException">Source array is empty</exception>
            <exception cref="T:System.IO.EndOfStreamException">Unexpected end of input data</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Input data is invalid</exception>
            <exception cref="T:System.NotSupportedException">Signature contains unsupported elements</exception>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Signature.#ctor(System.Byte[],CilTools.Reflection.ITokenResolver)">
            <summary>
            Initializes a new signature object, respoving metadata tokens using the specified resolver
            </summary>
            <param name="data">The byte array containing the signature data</param>
            <param name="resolver">The object used to resolve metadata tokens</param>
            <exception cref="T:System.ArgumentNullException">Source array is null</exception>
            <exception cref="T:System.ArgumentException">Source array is empty</exception>
            <exception cref="T:System.IO.EndOfStreamException">Unexpected end of input data</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Input data is invalid</exception>
            <exception cref="T:System.NotSupportedException">Signature contains unsupported elements</exception>
            <remarks>The signature could be the method signature or the standalone signature 
            (ECMA-335 II.23.2.3: StandAloneMethodSig)</remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Signature.#ctor(System.Byte[],CilTools.Reflection.ITokenResolver,System.Reflection.MemberInfo)">
            <summary>
            Initializes a new signature object, respoving metadata tokens using the specified resolver in 
            the specified generic context
            </summary>
            <param name="data">The byte array containing the signature data</param>
            <param name="resolver">The object used to resolve metadata tokens</param>
            <param name="member">Method that identifies generic context for generic method params, or null 
            if this signature does not belong to a generic method</param>
            <exception cref="T:System.ArgumentNullException">Source array is null</exception>
            <exception cref="T:System.ArgumentException">Source array is empty</exception>
            <exception cref="T:System.IO.EndOfStreamException">Unexpected end of input data</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Input data is invalid</exception>
            <exception cref="T:System.NotSupportedException">Signature contains unsupported elements</exception>
            <remarks>The signature could be the method signature or the standalone signature 
            (ECMA-335 II.23.2.3: StandAloneMethodSig)</remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Signature.#ctor(System.IO.Stream,CilTools.Reflection.ITokenResolver,System.Reflection.MemberInfo)">
            <summary>
            Initializes a new signature object from the stream, respoving metadata tokens using the specified 
            resolver in the specified generic context
            </summary>
            <param name="src">The stream to read signature data from</param>
            <param name="resolver">The object used to resolve metadata tokens</param>
            <param name="member">Method that identifies generic context for generic method params, or null 
            if this signature does not belong to a generic method</param>
            <exception cref="T:System.ArgumentNullException">Source stream is null</exception>
            <exception cref="T:System.IO.EndOfStreamException">Unexpected end of input data</exception>
            <exception cref="T:CilTools.BytecodeAnalysis.CilParserException">Input data is invalid</exception>
            <exception cref="T:System.NotSupportedException">Signature contains unsupported elements</exception>
            <remarks>The signature could be the method signature or the standalone signature 
            (ECMA-335 II.23.2.3: StandAloneMethodSig)</remarks>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Signature.ReadFieldSignature(System.Byte[],CilTools.Reflection.ITokenResolver,System.Reflection.MemberInfo)">
            <summary>
            Reads the field signature from the specified byte array
            </summary>
            <param name="data">The byte array containing the field signature data</param>
            <param name="resolver">The object used to resolve metadata tokens</param>
            <param name="member">Method that identifies generic context for generic method params, or null 
            if this signature does not belong to a generic method</param>
            <returns>The <c>TypeSpec</c> representing the field type</returns>
            <exception cref="T:System.ArgumentNullException">Source array is null</exception>
            <exception cref="T:System.ArgumentException">Source array is empty</exception>
            <exception cref="T:System.IO.InvalidDataException">
            The signature data does not represent the field signature
            </exception>
            <remarks>
            The field signature in .NET assembly consists of only the single <see cref="T:CilTools.BytecodeAnalysis.TypeSpec"/> that 
            represents the field type. The signature data passed to this method should not contain 
            data for signature types other then the field signature (such as the method signature), or 
            an exception will be thrown.
            </remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.Signature.CallingConvention">
            <summary>
            Returns calling convention of the function described by this signature
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.Signature.HasThis">
            <summary>
            Gets the value indicating whether the function described by this signature uses an instance pointer
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.Signature.ExplicitThis">
            <summary>
            Gets the value indicating whether the instance pointer is included explicitly in this signature
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.Signature.GenericInst">
            <summary>
            Gets the value indicating whether this signature represents the generic method instantiation
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.Signature.ReturnType">
            <summary>
            Gets the return type of the function described by this signature
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.Signature.ParamsCount">
            <summary>
            Gets the amount of fixed parameters that the function described by this signature takes
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.Signature.GenericArgsCount">
            <summary>
            Gets the generic arguments or parameters count for the generic method, or zero if this 
            signature does not represent the generic method.
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Signature.GetParamType(System.Int32)">
            <summary>
            Gets the type of parameter with the specified index
            </summary>
            <param name="index">Index of the requested parameter</param>
            <returns>The type of requested parameter</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is negative or outside the bounds of collection</exception>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.Signature.ParamTypes">
            <summary>
            Enumerates types of fixed parameters that the function described by this signature takes
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Signature.GetParamTypes">
            <summary>
            Gets the array of fixed parameter types that the function described by this signature takes
            </summary>
            <returns></returns>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.Signature.ToString">
            <summary>
            Gets the textual representation of this signature as CIL code
            </summary>        
        </member>
        <member name="T:CilTools.BytecodeAnalysis.ElementType">
            <summary>
            Represents signature element type as defined in ECMA-335
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Void">
            <summary>
            The absence of return value
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Boolean">
            <summary>
            System.Boolean
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Char">
            <summary>
            System.Char
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.I1">
            <summary>
            sbyte
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.U1">
            <summary>
            byte
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.I2">
            <summary>
            short
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.U2">
            <summary>
            ushort
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.I4">
            <summary>
            int
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.U4">
            <summary>
            uint
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.I8">
            <summary>
            long
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.U8">
            <summary>
            ulong
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.R4">
            <summary>
            float
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.R8">
            <summary>
            double
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.String">
            <summary>
            Sytem.String
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Ptr">
            <summary>
            Unmanaged pointer
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.ByRef">
            <summary>
            Passed by reference
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.ValueType">
            <summary>
            Value type
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Class">
            <summary>
            Reference type
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Var">
            <summary>
            Generic parameter in a generic type definition
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Array">
            <summary>
            Array
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.GenericInst">
            <summary>
            Generic type instantiation
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.TypedByRef">
            <summary>
            Passed by typed reference
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.I">
            <summary>
            System.IntPtr
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.U">
            <summary>
            System.UIntPtr
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.FnPtr">
            <summary>
            Function pointer
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Object">
            <summary>
            System.Object
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.SzArray">
            <summary>
            Single-dimensional array with 0 lower bound
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.MVar">
            <summary>
            Generic parameter in a generic method definition
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Internal">
            <summary>
            Implemented within the CLI
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Modifier">
            <summary>
            Modifier
            </summary>
        </member>
        <member name="F:CilTools.BytecodeAnalysis.ElementType.Sentinel">
            <summary>
            Sentinel for vararg method signature
            </summary>
        </member>
        <member name="T:CilTools.BytecodeAnalysis.TypeSpec">
            <summary>
            Represents type specification, the set of type information stored in the signature, as defined by ECMA-335
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.ReadFromArray(System.Byte[],CilTools.Reflection.ITokenResolver,System.Reflection.MemberInfo)">
            <summary>
            Reads <c>TypeSpec</c> object from the specified byte array
            </summary>
            <param name="data">Byte array to read data from</param>
            <param name="resolver">Object used to resolve metadata tokens</param>
            <param name="member">
            Method that identifies generic context for generic method params, or null if this <c>TypeSpec</c> 
            does not belong to a generic method
            </param>
            <returns></returns>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.ElementType">
            <summary>
            Gets the element type of this type specification 
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.ModifiersCount">
            <summary>
            Gets the amount of custom modifiers associated with this type specification 
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetModifier(System.Int32)">
            <summary>
            Gets the custom modifier with the specified index
            </summary>
            <param name="index">Index of the requested modifier</param>
            <returns>The requested custom modifier</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is negative or outside the bounds of the collection</exception>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.Modifiers">
            <summary>
            Enumerates custom modifiers associated with this type specification
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetModifiers">
            <summary>
            Gets the array of custom modifiers associated with this type specification
            </summary>
            <returns>The array of custom modifiers</returns>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.InnerTypeSpec">
            <summary>
            Gets the inner type specification if this instance represents an array or pointer type. For other types, the value is null
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.Type">
            <summary>
            Gets the type which this type specification represents (deprecated)
            </summary>
            <remarks>
            Starting from the version 2.1, the <c>TypeSpec</c> itself extends <c>System.Type</c>, so this property is not needed. 
            Use this object directly when you need an instance of <c>System.Type</c>, or the <see cref="P:CilTools.BytecodeAnalysis.TypeSpec.UnderlyingSystemType"/> property 
            if you need the runtime type. This property will be removed in future releases.
            </remarks>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.IsPinned">
            <summary>
            Gets the value indicating whether this TypeSpec represents pinned local variable
            </summary>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.GUID">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.Module">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.Assembly">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.FullName">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.Namespace">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.AssemblyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.BaseType">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.UnderlyingSystemType">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.Name">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetConstructors(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetMethods(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetField(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetFields(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetInterface(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetInterfaces">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetEvent(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetEvents(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetProperties(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetNestedTypes(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetNestedType(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetMembers(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetAttributeFlagsImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.IsArrayImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.IsByRefImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.IsPointerImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.IsPrimitiveImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.IsCOMObjectImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetElementType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.HasElementTypeImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetCustomAttributes(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetCustomAttributes(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.IsDefined(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.MetadataToken">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetArrayRank">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.MakeArrayType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.MakeByRefType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.MakePointerType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.MakeGenericType(System.Type[])">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.DeclaringType">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.DeclaringMethod">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.IsGenericParameter">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.GenericParameterPosition">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.IsGenericType">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.IsGenericTypeDefinition">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.BytecodeAnalysis.TypeSpec.TargetSignature">
            <summary>
            Gets the target function signature, if this <c>TypeSpec</c> represents a function pointer. Otherwise, returns null.
            </summary>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetGenericArguments">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.GetGenericTypeDefinition">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.ToString">
            <summary>
            Returns textual representation of this type specification as CIL code
            </summary>        
        </member>
        <member name="M:CilTools.BytecodeAnalysis.TypeSpec.IsFunctionPointer">
            <summary>
            Gets a value indicating whether this <c>TypeSpec</c> represents a function pointer
            </summary>
            <returns></returns>
        </member>
        <member name="T:CilTools.Reflection.ComplexTypeKind">
            <summary>
            Specifies the kind of the complex type
            </summary>
        </member>
        <member name="F:CilTools.Reflection.ComplexTypeKind.SzArray">
            <summary>
            Single-dimensional zero-based array
            </summary>
        </member>
        <member name="F:CilTools.Reflection.ComplexTypeKind.ByRef">
            <summary>
            Managed reference
            </summary>
        </member>
        <member name="F:CilTools.Reflection.ComplexTypeKind.Pointer">
            <summary>
            Unmanaged pointer
            </summary>
        </member>
        <member name="F:CilTools.Reflection.ComplexTypeKind.GenInst">
            <summary>
            Generic type instantiation
            </summary>
        </member>
        <member name="T:CilTools.Reflection.ComplexType">
            <summary>
            Represents a complex type. Complex type is a type contructed on demand based on another type defined in some assembly, 
            for example, an array or pointer type.
            </summary>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.#ctor(System.Type,CilTools.Reflection.ComplexTypeKind,System.Type[])">
            <summary>
            Creates new instance of the complex type
            </summary>
            <param name="t">Element type</param>
            <param name="k">Kind of the complex type</param>
            <param name="ga">An array of generic type arguments, or null if this is not a generic type instantiation</param>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.Assembly">
            <inheritdoc/>        
        </member>
        <member name="P:CilTools.Reflection.ComplexType.AssemblyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.BaseType">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.FullName">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.GUID">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetAttributeFlagsImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetConstructors(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetElementType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetEvent(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetEvents(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetField(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetFields(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetInterface(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetInterfaces">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetMember(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetMembers(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetMethods(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetNestedType(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetNestedTypes(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetProperties(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.HasElementTypeImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.IsArrayImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.IsByRefImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.IsCOMObjectImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.IsPointerImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.IsPrimitiveImpl">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.Module">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.Namespace">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.UnderlyingSystemType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetCustomAttributes(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetCustomAttributes(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.IsDefined(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.Name">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.MetadataToken">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetArrayRank">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.IsGenericType">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.IsGenericTypeDefinition">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetGenericTypeDefinition">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.GetGenericArguments">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.MakeArrayType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.MakeByRefType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.MakePointerType">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.ComplexType.DeclaringType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.ComplexType.ToString">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Reflection.CustomMethod">
            <summary>
            A base class for MethodBase implementations providing custom mechanisms for extracting bytecode data. 
            Inherit from this class when you want CilTools.BytecodeAnalysis to process bytecode from your custom data source, instead of 
            reflection.
            </summary>
        </member>
        <member name="P:CilTools.Reflection.CustomMethod.ReturnType">
            <summary>
            When overridden in the derived class, returns the type of this method's return value
            </summary>
            <remarks>Return null if the return type is not applicable (such as for constructors).</remarks>
        </member>
        <member name="P:CilTools.Reflection.CustomMethod.TokenResolver">
            <summary>
            When overridden in the derived class, returns an object that can be used to convert metadata tokens 
            into corresponding reflection objects
            </summary>
        </member>
        <member name="M:CilTools.Reflection.CustomMethod.GetBytecode">
            <summary>
            When overridden in the derived class, returns the CIL bytecode of the method body
            </summary>
            <returns>CIL bytecode as byte array</returns>
        </member>
        <member name="P:CilTools.Reflection.CustomMethod.MaxStackSize">
            <summary>
            When overridden in the derived class, returns the maximum size of operand stack during method execution
            </summary>
        </member>
        <member name="P:CilTools.Reflection.CustomMethod.MaxStackSizeSpecified">
            <summary>
            When overridden in the derived class, specifies whether the MaxStackSize property value is defined
            </summary>
        </member>
        <member name="P:CilTools.Reflection.CustomMethod.InitLocals">
            <summary>
            When overridden in the derived class, specifies whether the local variables are initialized
            </summary>
        </member>
        <member name="P:CilTools.Reflection.CustomMethod.InitLocalsSpecified">
            <summary>
            When overridden in the derived class, specifies whether the <c>InitLocals</c> property value is defined
            </summary>
        </member>
        <member name="M:CilTools.Reflection.CustomMethod.GetLocalVarSignature">
            <summary>
            When overridden in the derived class, returns the local variable signature as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:CilTools.Reflection.CustomMethod.GetExceptionBlocks">
            <summary>
            When overridden in the derived class, returns the list of exception handling blocks in the method's body
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.CustomMethod.GetLocalVariables">
            <summary>
            Returns the array of local variable declarations of this method
            </summary>
            <remarks>
            The default implementation reads local varaibles from the signature returned by GetLocalVarSignature method
            </remarks>
        </member>
        <member name="M:CilTools.Reflection.CustomMethod.GetDefinition">
            <summary>
            When overridden in the derived class, gets the method definition for the generic method. 
            Returns null if this instance does not represent the generic method.
            </summary>
            <remarks>
            The default implementation always returns null
            </remarks>
        </member>
        <member name="M:CilTools.Reflection.CustomMethod.GetPInvokeParams">
            <summary>
            When overridden in the derived class, gets P/Invoke parameters for the imported unmanaged 
            method. Returns null if this instance does not represent an imported unmanaged method.
            </summary>
            <remarks>
            The default implementation always returns null
            </remarks>
        </member>
        <member name="M:CilTools.Reflection.CustomMethod.PrepareMethod(System.Reflection.MethodBase)">
            <summary>
            Converts MethodBase into the form suitable for processing by CilTools.BytecodeAnalysis
            </summary>
        </member>
        <member name="M:CilTools.Reflection.CustomMethod.CreateResolver(System.Reflection.MethodBase)">
            <summary>
            Creates an object that can be used to resolve tokens in the context of specified method
            </summary>
        </member>
        <member name="T:CilTools.Reflection.ExceptionBlock">
            <summary>
            Represents an exception handling block
            </summary>
        </member>
        <member name="M:CilTools.Reflection.ExceptionBlock.#ctor(System.Reflection.ExceptionHandlingClauseOptions,System.Int32,System.Int32,System.Type,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new ExceptionBlock instance using provided property values
            </summary>        
        </member>
        <member name="P:CilTools.Reflection.ExceptionBlock.CatchType">
            <summary>
            Gets the type of exception handled by the catch block
            </summary>
        </member>
        <member name="P:CilTools.Reflection.ExceptionBlock.FilterOffset">
            <summary>
            Gets the offset of this block's exception filter within the method body, in bytes
            </summary>
        </member>
        <member name="P:CilTools.Reflection.ExceptionBlock.Flags">
            <summary>
            Gets the value specifying the type of exception block
            </summary>
        </member>
        <member name="P:CilTools.Reflection.ExceptionBlock.HandlerLength">
            <summary>
            Gets the length of this block's handler, in bytes
            </summary>
        </member>
        <member name="P:CilTools.Reflection.ExceptionBlock.HandlerOffset">
            <summary>
            Gets the offset of this block's handler within the method body, in bytes
            </summary>
        </member>
        <member name="P:CilTools.Reflection.ExceptionBlock.TryLength">
            <summary>
            Gets the length of this block's try clause, in bytes
            </summary>
        </member>
        <member name="P:CilTools.Reflection.ExceptionBlock.TryOffset">
            <summary>
            Gets the offset of this block's try clause within the method body, in bytes
            </summary>
        </member>
        <member name="M:CilTools.Reflection.ExceptionBlock.FromReflection(System.Reflection.ExceptionHandlingClause)">
            <summary>
            Creates new ExceptionBlock instance based on the specified reflection ExceptionHandlingClause object
            </summary>        
        </member>
        <member name="T:CilTools.Reflection.GenericParamType">
            <summary>
            Represents the generic parameter
            </summary>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.#ctor(System.Reflection.MethodBase,System.Int32)">
            <summary>
            Creates a new instance of the generic parameter
            </summary>
            <param name="m">Declaring method, if this is a generic method parameter</param>
            <param name="index">Generic parameter index</param>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.#ctor(System.Reflection.MethodBase,System.Int32,System.String)">
            <summary>
            Creates a new instance of the generic parameter with the specified name
            </summary>
            <param name="m">Declaring method, if this is a generic method parameter</param>
            <param name="index">Generic parameter index</param>
            <param name="name">Generic parameter name</param>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.Assembly">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.AssemblyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.BaseType">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.FullName">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.GUID">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetAttributeFlagsImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetConstructors(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetElementType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetEvent(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetEvents(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetField(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetFields(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetInterface(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetInterfaces">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetMember(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetMembers(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetMethods(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetNestedType(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetNestedTypes(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetProperties(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.HasElementTypeImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.IsArrayImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.IsByRefImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.IsCOMObjectImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.IsPointerImpl">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.IsPrimitiveImpl">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.Module">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.Namespace">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.UnderlyingSystemType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetCustomAttributes(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetCustomAttributes(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.IsDefined(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.Name">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.MetadataToken">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.GetArrayRank">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.IsGenericParameter">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.GenericParameterPosition">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Reflection.GenericParamType.DeclaringMethod">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.MakeArrayType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.MakeByRefType">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Reflection.GenericParamType.MakePointerType">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Reflection.ICustomAttribute">
            <summary>
            Represents the custom attribute data
            </summary>
            <remarks>
            This interface is needed to support fetching custom attribute data in reflection-only mode 
            in .NET Framework 3.5. The library treats objects that implement <c>ICustomAttribute</c> in a 
            special way when processing an array returned by <c>MethodBase.GetCustomAttributes</c>, 
            fetching raw attribute data instead of attempting to emulate that data based on what reflection 
            returns for an attribute type. Implement this interface when you need to pass your custom method 
            object to APIs like <see cref="T:CilTools.BytecodeAnalysis.CilGraph"/> and make it possible to 
            read raw data of method's custom attributes.
            </remarks>
        </member>
        <member name="P:CilTools.Reflection.ICustomAttribute.Owner">
            <summary>
            Gets the method this attribute is attached to
            </summary>
        </member>
        <member name="P:CilTools.Reflection.ICustomAttribute.Constructor">
            <summary>
            Gets the constructor used to instantiate object of this attribute
            </summary>
        </member>
        <member name="P:CilTools.Reflection.ICustomAttribute.Data">
            <summary>
            Gets the raw attribute data as the byte array
            </summary>
            <remarks>
            The format of the byte array is defined by ECMA-335 specification, paragraph II.23.3 - 
            Custom attributes. The data in the byte array specifies constructor's arguments and 
            property values used to create an object for this attribute.
            </remarks>
        </member>
        <member name="T:CilTools.Reflection.ITokenResolver">
            <summary>
            Represents an object that can be used to convert metadata tokens into corresponding high-level reflection objects
            </summary>
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveType(System.Int32,System.Type[],System.Type[])">
            <summary>
            Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveType(System.Int32)">
            <summary>
            Returns the type identified by the specified metadata token.
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveMethod(System.Int32,System.Type[],System.Type[])">
            <summary>
            Returns the method or constructor identified by the specified metadata token, in the context defined by the 
            specified generic type parameters.
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveMethod(System.Int32)">
            <summary>
            Returns the method or constructor identified by the specified metadata token.
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveField(System.Int32,System.Type[],System.Type[])">
            <summary>
            Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveField(System.Int32)">
            <summary>
            Returns the field identified by the specified metadata token.
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveMember(System.Int32,System.Type[],System.Type[])">
            <summary>
            Returns the type or member identified by the specified metadata token, in the context defined by the specified 
            generic type parameters.
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveMember(System.Int32)">
            <summary>
            Returns the type or member identified by the specified metadata token.
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveSignature(System.Int32)">
            <summary>
            Returns the signature blob identified by a metadata token.
            </summary>        
            <returns>An array of bytes representing the signature blob.</returns>
        </member>
        <member name="M:CilTools.Reflection.ITokenResolver.ResolveString(System.Int32)">
            <summary>
            Returns the string identified by the specified metadata token.
            </summary>        
        </member>
        <member name="T:CilTools.Reflection.LocalVariable">
            <summary>
            Represents local variable declaration in the method body
            </summary>
        </member>
        <member name="M:CilTools.Reflection.LocalVariable.#ctor(CilTools.BytecodeAnalysis.TypeSpec,System.Int32)">
            <summary>
            Initializes a new LocalVariable instance with the specified TypeSpec and index
            </summary>
            <param name="ptype">TypeSpec object representing the variable type</param>
            <param name="pindex">Index of local variable within method body</param>
        </member>
        <member name="P:CilTools.Reflection.LocalVariable.LocalTypeSpec">
            <summary>
            Gets the TypeSpec object representing the variable type
            </summary>
        </member>
        <member name="P:CilTools.Reflection.LocalVariable.LocalType">
            <summary>
            Gets the variable type
            </summary>
        </member>
        <member name="P:CilTools.Reflection.LocalVariable.LocalIndex">
            <summary>
            Gets the index of local variable within the containing method body
            </summary>
        </member>
        <member name="P:CilTools.Reflection.LocalVariable.IsPinned">
            <summary>
            Gets the value indicating whether the object pointed by local variable is pinned in memory
            </summary>
        </member>
        <member name="M:CilTools.Reflection.LocalVariable.ReadSignature(System.Byte[],CilTools.Reflection.ITokenResolver)">
            <summary>
            Reads local variables from the specified signature, resolving tokens using the specified ITokenResolver
            </summary>
            <param name="data">Local variable signature as byte array</param>
            <param name="resolver">The object used to resolve metadata tokens</param>
            <returns>An array of local variables read from the signature</returns>
            <exception cref="T:System.ArgumentNullException">Input array is null</exception>
            <exception cref="T:System.NotSupportedException">Signature contains unsupported types</exception>
        </member>
        <member name="M:CilTools.Reflection.LocalVariable.ReadSignature(System.Byte[],CilTools.Reflection.ITokenResolver,System.Reflection.MemberInfo)">
            <summary>
            Reads local variables from the specified signature, resolving tokens using the specified 
            <see cref="T:CilTools.Reflection.ITokenResolver"/> in a generic context identified by the specified member reference.
            </summary>
            <param name="data">Local variable signature as byte array</param>
            <param name="resolver">The object used to resolve metadata tokens</param>
            <param name="member">Method that identifies generic context for generic method params, or null if 
            this signature does not belong to a generic method</param>
            <returns>An array of local variables read from the signature</returns>
            <exception cref="T:System.ArgumentNullException">Input array is null</exception>
            <exception cref="T:System.NotSupportedException">Signature contains unsupported types</exception>
        </member>
        <member name="M:CilTools.Reflection.LocalVariable.ReadSignature(System.Byte[],System.Reflection.Module)">
            <summary>
            Reads local variables from the specified signature, resolving tokens within the scope of the specified module
            </summary>
            <param name="data">Local variable signature as byte array</param>
            <param name="module">Module in which to resolve metadata tokens</param>
            <returns>An array of local variables read from the signature</returns>
            <exception cref="T:System.ArgumentNullException">Input array is null</exception>
            <exception cref="T:System.NotSupportedException">Signature contains unsupported types</exception>
        </member>
        <member name="M:CilTools.Reflection.LocalVariable.FromReflection(System.Reflection.MethodBase)">
            <summary>
            Reads local variables from the specified method's body
            </summary>
            <param name="mb">Source method</param>
            <returns>An array of local variables read from the method body</returns>
        </member>
        <member name="T:CilTools.Reflection.ModuleWrapper">
            <summary>
            Resolves metadata tokens in the context of the specified module
            </summary>
        </member>
        <member name="M:CilTools.Reflection.ModuleWrapper.#ctor(System.Reflection.MethodBase)">
            <summary>
            Creates ModuleWrapper object using the module containing the specified method
            </summary>        
        </member>
        <member name="M:CilTools.Reflection.ModuleWrapper.#ctor(System.Reflection.Module)">
            <summary>
            Creates ModuleWrapper object using the explicitly specified module
            </summary>        
        </member>
        <member name="T:CilTools.Reflection.ModuleWrapperDynamic">
            <summary>
            Resolves metadata tokens in the context of specified dynamic method
            </summary>
        </member>
        <member name="T:CilTools.Reflection.PInvokeParams">
            <summary>
            Represents the parameters of the imported unmanaged method 
            </summary>
            <remarks>
            <para>This type is used with the <see cref="M:CilTools.Reflection.CustomMethod.GetPInvokeParams"/> method.</para>
            <para>Imported unmanaged method is a method implemented as a Platform Invoke (P/Invoke) call. 
            The call to such method is marshalled into the call to corresponding native function by 
            Common Language Runtime. P/Invoke method is defined in .NET using <see cref="T:System.Runtime.InteropServices.DllImportAttribute"/>. 
            See the .NET documentation for more information about P/Invoke: 
            <see href="https://docs.microsoft.com/dotnet/standard/native-interop/pinvoke"/>.
            </para>
            </remarks>
        </member>
        <member name="M:CilTools.Reflection.PInvokeParams.#ctor(System.String,System.String,System.Runtime.InteropServices.CharSet,System.Boolean,System.Boolean,System.Nullable{System.Boolean},System.Runtime.InteropServices.CallingConvention)">
            <summary>
            Creates the new instance of <c>PInvokeParams</c> object.
            </summary>
            <param name="module">Unmanaged module from which the method is imported</param>
            <param name="func">The name of the imported native function</param>
            <param name="charSet">The character set used by this method</param>
            <param name="exactSpelling">
            The value indicating that the marshaller should not probe for charset-specific names 
            when searching for an entry point. 
            </param>
            <param name="setLastError">
            The value indicating that the imported function sets the last WinAPI error.
            </param>
            <param name="bestFitMapping">
            The value indicating whether the marshaller should use the best fit mapping behaviour when 
            converting characters between character sets.
            </param>
            <param name="callConv">The clling convention of the imported function.</param>
        </member>
        <member name="P:CilTools.Reflection.PInvokeParams.ModuleName">
            <summary>
            Gets the name of the unmanaged module from which the method is imported
            </summary>
        </member>
        <member name="P:CilTools.Reflection.PInvokeParams.FunctionName">
            <summary>
            Gets the name of the imported native function
            </summary>
        </member>
        <member name="P:CilTools.Reflection.PInvokeParams.CharSet">
            <summary>
            Gets the character set used by this method
            </summary>
        </member>
        <member name="P:CilTools.Reflection.PInvokeParams.ExactSpelling">
            <summary>
            Gets the value indicating that the marshaller should not probe for charset-specific names 
            when searching for an entry point.
            </summary>
        </member>
        <member name="P:CilTools.Reflection.PInvokeParams.SetLastError">
            <summary>
            Gets the value indicating that the imported function sets the last WinAPI error.
            </summary>
        </member>
        <member name="P:CilTools.Reflection.PInvokeParams.BestFitMapping">
            <summary>
            Gets the value indicating whether the marshaller should use the best fit mapping behaviour when 
            converting characters between character sets.
            </summary>
        </member>
        <member name="P:CilTools.Reflection.PInvokeParams.CallingConvention">
            <summary>
            Gets the calling convention for the imported function.
            </summary>
            <remarks>
            Calling convention is a set of rules defining how the function interacts with its caller. See 
            <see href="https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions"/> 
            for more information about native calling conventions.
            </remarks>
        </member>
        <member name="T:CilTools.Syntax.BlockSyntax">
            <summary>
            Represents the block syntax in the CIL assembler. The block contains child directive and instruction nodes.
            </summary>
            <remarks>
            The examples of block syntax are method body or exception handler blocks. The block consists of the optional header, opening curly brace, content nodes 
            (directives and statements) and closing curly brace.
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.BlockSyntax.HeaderSyntax">
            <summary>
            Gets the header syntax of this block, or an empty collection if this block has no header
            </summary>
            <remarks>
            For the exception handler blocks, the header represents the exception clause. Other types of blocks does not have headers.
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.BlockSyntax.Content">
            <summary>
            Returns the collection of the syntax nodes contained within this block (content nodes)
            </summary>
            <remarks>
            The content nodes are located between opening and closing curly braces. They include instructions and directives.
            </remarks>
        </member>
        <member name="M:CilTools.Syntax.BlockSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.BlockSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Syntax.CommentSyntax">
            <summary>
            Represents the comment in the CIL assembler code. The comment does not impact code semantics in any way, but may provide extra information.
            </summary>
        </member>
        <member name="M:CilTools.Syntax.CommentSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.CommentSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Syntax.DirectiveSyntax">
            <summary>
            Represents the directive in CIL assembler. The directive declaration starts from the dotted name.
            </summary>
            <remarks>
            The directive provides meta-information, such as the method's signature or the declarations of local variables.
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.DirectiveSyntax.Name">
            <summary>
            Gets the name of this directive
            </summary>
        </member>
        <member name="M:CilTools.Syntax.DirectiveSyntax.WriteContent(System.IO.TextWriter)">
            <summary>
            Writes text representation of this directive's content into the specified TextWriter
            </summary>
        </member>
        <member name="P:CilTools.Syntax.DirectiveSyntax.ContentString">
            <summary>
            Gets the text representation of this directive's content
            </summary>
        </member>
        <member name="P:CilTools.Syntax.DirectiveSyntax.ContentSyntax">
            <summary>
            Gets the collection of nodes that represent this directive's content
            </summary>
        </member>
        <member name="M:CilTools.Syntax.DirectiveSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.DirectiveSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Syntax.IdentifierSyntax">
            <summary>
            Represents identifier in CIL assembler. Identifier is a name of the member or variable.
            </summary>
        </member>
        <member name="P:CilTools.Syntax.IdentifierSyntax.Content">
            <summary>
            Gets the content of this identifier as string
            </summary>
        </member>
        <member name="P:CilTools.Syntax.IdentifierSyntax.IsMemberName">
            <summary>
            Gets the value indicating whether this identifier represents assembly member name
            </summary>
        </member>
        <member name="M:CilTools.Syntax.IdentifierSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.IdentifierSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Syntax.InstructionSyntax">
            <summary>
            Represents instruction syntax in CIL assembler
            </summary>
            <remarks>The instruction syntax consists of the optional label, operation name, and the optional operand</remarks>
        </member>
        <member name="M:CilTools.Syntax.InstructionSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.InstructionSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="P:CilTools.Syntax.InstructionSyntax.Label">
            <summary>
            Gets the label name of this instruction
            </summary>
        </member>
        <member name="M:CilTools.Syntax.InstructionSyntax.WriteLabel(System.IO.TextWriter)">
            <summary>
            Writes the label name of this instruction into the specified TextWriter
            </summary>
        </member>
        <member name="P:CilTools.Syntax.InstructionSyntax.Operation">
            <summary>
            Gets the operation name of this instruction
            </summary>
        </member>
        <member name="M:CilTools.Syntax.InstructionSyntax.WriteOperation(System.IO.TextWriter)">
            <summary>
            Writes the operation name of this instruction into the specified TextWriter
            </summary>
        </member>
        <member name="P:CilTools.Syntax.InstructionSyntax.Instruction">
            <summary>
            Returns the instruction instance corresponding to this node
            </summary>
        </member>
        <member name="M:CilTools.Syntax.InstructionSyntax.WriteOperand(System.IO.TextWriter)">
            <summary>
            Writes the operand of this instruction into the specified TextWriter
            </summary>
        </member>
        <member name="P:CilTools.Syntax.InstructionSyntax.OperandString">
            <summary>
            Gets the text representation of this instruction's operand 
            </summary>
        </member>
        <member name="P:CilTools.Syntax.InstructionSyntax.OperandSyntax">
            <summary>
            Gets the collection of nodes representing this instruction operand's syntax
            </summary>
        </member>
        <member name="T:CilTools.Syntax.KeywordKind">
            <summary>
            Represents the kind of keyword in the <see cref="T:CilTools.Syntax.KeywordSyntax"/> node
            </summary>
        </member>
        <member name="F:CilTools.Syntax.KeywordKind.Other">
            <summary>
            Unclassifed
            </summary>
        </member>
        <member name="F:CilTools.Syntax.KeywordKind.DirectiveName">
            <summary>
            The name of directive
            </summary>
        </member>
        <member name="F:CilTools.Syntax.KeywordKind.InstructionName">
            <summary>
            The name of instruction
            </summary>
        </member>
        <member name="T:CilTools.Syntax.KeywordSyntax">
            <summary>
            Represents the keyword token in CIL assembler. 
            </summary>
            <remarks> 
            The keyword is a special sequence of characters that can't be used as identifier. 
            The list of keywords is predefined by specification. 
            The keyword could represent the directive name, access modifier, instruction name 
            or other special syntactic element.
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.KeywordSyntax.Content">
            <summary>
            Gets the value of this keyword as string
            </summary>
        </member>
        <member name="P:CilTools.Syntax.KeywordSyntax.Kind">
            <summary>
            Gets the keyword kind
            </summary>
        </member>
        <member name="M:CilTools.Syntax.KeywordSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.KeywordSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Syntax.LiteralSyntax">
            <summary>
            Represents the syntax of literal constant (such as numeric or string) in CIL assembler
            </summary>
            <remarks>
            Literal constant value is inlined directly in the source code. Typically literal syntax is used to 
            represent the operand of the instruction.
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.LiteralSyntax.Value">
            <summary>
            Gets the value represented by this literal
            </summary>
        </member>
        <member name="M:CilTools.Syntax.LiteralSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.LiteralSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Syntax.MemberRefSyntax">
            <summary>
            Represents the reference to the assembly member (such as type, method or field) in CIL assembler
            </summary>
            <remarks>
            The member reference syntax is used as instruction operand or in variable declarations. 
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.MemberRefSyntax.Member">
            <summary>
            Gets the reflection construct representing the referenced member
            </summary>
        </member>
        <member name="M:CilTools.Syntax.MemberRefSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.MemberRefSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Syntax.MethodDefSyntax">
            <summary>
            Represents the syntax of the method definition in CIL assembler
            </summary>
            <remarks>
            Method definition consists of the signature ("header") and the body. The body can contain directives 
            (such as custom attributes or local variable declarations) and instructions.
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.MethodDefSyntax.Signature">
            <summary>
            Gets the directive representing the signature of the defined method
            </summary>
        </member>
        <member name="P:CilTools.Syntax.MethodDefSyntax.Body">
            <summary>
            Gets the block that forms the body of the defined method
            </summary>
        </member>
        <member name="M:CilTools.Syntax.MethodDefSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.MethodDefSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Syntax.PunctuationSyntax">
            <summary>
            Represents the punctuation sign token in CIL assembler
            </summary>
            <remarks>
            Punctuation signs divide other tokens in syntax constructs. Punctuation signs used in CIL are colons, 
            braces, angle braces and others. 
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.PunctuationSyntax.Content">
            <summary>
            Gets the value of this punctuation sign as string
            </summary>
        </member>
        <member name="M:CilTools.Syntax.PunctuationSyntax.ToText(System.IO.TextWriter)">
            <inheritdoc/>
        </member>
        <member name="M:CilTools.Syntax.PunctuationSyntax.EnumerateChildNodes">
            <inheritdoc/>
        </member>
        <member name="T:CilTools.Syntax.SyntaxNode">
            <summary>
            Represents node in the syntax tree of Common Intermediate Language (CIL) assembler code. Classes that represent concrete language constructs derive from this class. 
            </summary>
            <remarks>
            <para>
            The <c>SyntaxNode</c> class instance contains all information required to produce the source code of the corresponding language construct, including whitespaces. 
            The <see cref="M:CilTools.Syntax.SyntaxNode.EnumerateChildNodes"/> method returns all child nodes of this node, or an empty collection if it is a leaf (terminal node). 
            Some child nodes may be exposed via specific properties as well. 
            The text representation for non-terminal node is a string concetanation of all its child nodes' text representations. 
            </para>
            <para>Use <see cref="M:CilTools.BytecodeAnalysis.CilGraph.ToSyntaxTree"/> method to get the syntax tree for the specified method.</para>
            </remarks>
        </member>
        <member name="M:CilTools.Syntax.SyntaxNode.ToText(System.IO.TextWriter)">
            <summary>
            Writes text representation of this node into the specified TextWriter
            </summary>
        </member>
        <member name="M:CilTools.Syntax.SyntaxNode.EnumerateChildNodes">
            <summary>
            Enumerates child nodes of this node. For the leaf node, returns an empty collection.
            </summary>
            <returns>The collection of child syntax nodes</returns>
        </member>
        <member name="P:CilTools.Syntax.SyntaxNode.LeadingWhitespace">
            <summary>
            Gets whitespace content at the beginning of this node's code
            </summary>
            <remarks>
            Besides the whitespace character itself, the returned string may contain line feed or carriage return characters. For efficiency purposes, the whitespace 
            content, both syntactically meaningful and indentation-only, is stored within one of the adjacent nodes, not in the separate node.
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.SyntaxNode.TrailingWhitespace">
            <summary>
            Gets whitespace content at the end of this node's code
            </summary>
            <remarks>
            Besides the whitespace character itself, the returned string may contain line feed or carriage return characters. For efficiency purposes, the whitespace 
            content, both syntactically meaningful and indentation-only, is stored within one of the adjacent nodes, not in the separate node.
            </remarks>
        </member>
        <member name="P:CilTools.Syntax.SyntaxNode.Parent">
            <summary>
            Gets the parent node of this syntax node, or null if this node is root or not included in syntax tree.
            </summary>
        </member>
        <member name="M:CilTools.Syntax.SyntaxNode.ToString">
            <summary>
            Gets the text representation of this node, including whitespace content
            </summary>
            <returns>The string containing CIL code of this syntax node</returns>
        </member>
        <member name="M:CilTools.Syntax.SyntaxNode.GetChildNodes">
            <summary>
            Gets the array of this node's child nodes. For the leaf node, returns an empty array.
            </summary>
            <returns>The array of child syntax nodes</returns>
        </member>
    </members>
</doc>
